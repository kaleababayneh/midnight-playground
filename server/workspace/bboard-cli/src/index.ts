import { createInterface, type Interface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { WebSocket } from 'ws';
import dotenv from 'dotenv';
// import { webcrypto } from 'crypto';
import {
  type BBoardProviders,
  BBoardAPI,
  utils,
  type BBoardDerivedState,
  type DeployedBBoardContract,
  type PrivateStateId,
  bboardPrivateStateKey,
} from '../../api/src/index';
import { ledger, type Ledger } from '../../contract/src/managed/bboard/contract/index.cjs';
import {
  type BalancedTransaction,
  createBalancedTx,
  type MidnightProvider,
  type UnbalancedTransaction,
  type WalletProvider,
} from '@midnight-ntwrk/midnight-js-types';
import { type Wallet } from '@midnight-ntwrk/wallet-api';
import * as Rx from 'rxjs';
import { type CoinInfo, nativeToken, Transaction, type TransactionId } from '@midnight-ntwrk/ledger';
import { Transaction as ZswapTransaction } from '@midnight-ntwrk/zswap';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type Resource, WalletBuilder } from '@midnight-ntwrk/wallet';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { type Logger } from 'pino';
import { type Config, StandaloneConfig } from './config.js';
import type { StartedDockerComposeEnvironment, DockerComposeEnvironment } from 'testcontainers';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { type ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { toHex, assertIsContractAddress } from '@midnight-ntwrk/midnight-js-utils';
import { getLedgerNetworkId, getZswapNetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { EnhancedBBoardAPI } from './enhanced-api.js';

// Configure dotenv to load environment variables from .env file in project root
dotenv.config({ path: '../.env' });

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;
const GENESIS_MINT_WALLET_SEED = '0000000000000000000000000000000000000000000000000000000000000001';
/* **********************************************************************
 * getBBoardLedgerState: a helper that queries the current state of
 * the data on the ledger, for a specific bulletin board contract.
 * Note that the Ledger type returned here is not some generic,
 * abstract ledger object, but specifically the type generated by
 * the Compact compiler to correspond to the ledger declaration
 * in the bulletin board contract.
 */

export const getBBoardLedgerState = async (
  providers: BBoardProviders,
  contractAddress: ContractAddress,
): Promise<Ledger | null> => {
  assertIsContractAddress(contractAddress);
  const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
  return contractState != null ? ledger(contractState.data) : null;
};
// providers.publicDataProvider
//   .queryContractState(contractAddress)
//   .then((contractState) => (contractState != null ? ledger(contractState.data) : null));

/* **********************************************************************
 * deployOrJoin: automatically deploys a new bulletin board contract
 * without prompting the user for choices.
 */

const deployOrJoin = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<EnhancedBBoardAPI | null> => {
  // Automatically deploy a new contract without asking questions
  logger.info('Deploying new bulletin board contract...');
  const api = await BBoardAPI.deploy(providers, logger);
  logger.info(`Deployed contract at address: ${api.deployedContractAddress}`);
  
  // Create and initialize enhanced API
  const enhancedApi = new EnhancedBBoardAPI(logger);
  await enhancedApi.initialize(api);
  logger.info('Enhanced API initialized with dynamic contract analysis');
  
  return enhancedApi;
};

/* **********************************************************************
 * displayLedgerState: dynamically shows the current contract state
 */

const displayLedgerState = async (
  providers: BBoardProviders,
  deployedBBoardContract: DeployedBBoardContract,
  logger: Logger,
): Promise<void> => {
  const contractAddress = deployedBBoardContract.deployTxData.public.contractAddress;
  const ledgerState = await getBBoardLedgerState(providers, contractAddress);
  if (ledgerState === null) {
    logger.info(`There is no contract deployed at ${contractAddress}`);
  } else {
    logger.info(`üìä Current Contract State:`);
    
    // Dynamically display all ledger fields
    Object.entries(ledgerState).forEach(([key, value]) => {
      if (typeof value === 'bigint') {
        logger.info(`  ${key}: ${value.toString()}`);
      } else if (typeof value === 'object' && value !== null) {
        logger.info(`  ${key}: ${JSON.stringify(value)}`);
      } else {
        logger.info(`  ${key}: ${value}`);
      }
    });
  }
};

/* **********************************************************************
 * displayPrivateState: shows the hex-formatted value of the secret key.
 */

const displayPrivateState = async (providers: BBoardProviders, logger: Logger): Promise<void> => {
  const privateState = await providers.privateStateProvider.get(bboardPrivateStateKey);
  if (privateState === null) {
    logger.info(`There is no existing bulletin board private state`);
  } else {
    logger.info(`Current secret key is: ${toHex(privateState.secretKey)}`);
  }
};

/* **********************************************************************
 * displayDerivedState: dynamically shows derived state information
 */

const displayDerivedState = (ledgerState: BBoardDerivedState | undefined, logger: Logger) => {
  if (ledgerState === undefined) {
    logger.info(`No contract state currently available`);
  } else {
    logger.info(`üìà Current Derived State:`);
    
    // Dynamically display all derived state fields
    Object.entries(ledgerState).forEach(([key, value]) => {
      if (typeof value === 'bigint') {
        logger.info(`  ${key}: ${value.toString()}`);
      } else if (typeof value === 'boolean') {
        logger.info(`  ${key}: ${value ? 'yes' : 'no'}`);
      } else if (typeof value === 'object' && value !== null) {
        logger.info(`  ${key}: ${JSON.stringify(value)}`);
      } else {
        logger.info(`  ${key}: ${value}`);
      }
    });
  }
};

/* **********************************************************************
 * mainLoop: the main interactive menu - completely dynamic based on contract analysis
 */

const mainLoop = async (providers: BBoardProviders, rli: Interface, logger: Logger): Promise<void> => {
  const enhancedApi = await deployOrJoin(providers, rli, logger);
  if (enhancedApi === null) {
    return;
  }

  // Make enhancedApi and helper functions globally available for the dynamic CLI
  (global as any).enhancedApi = enhancedApi;
  (global as any).getBBoardLedgerState = getBBoardLedgerState;
  (global as any).displayLedgerState = displayLedgerState;
  (global as any).displayPrivateState = displayPrivateState;
  (global as any).displayDerivedState = displayDerivedState;

  const bboardApi = enhancedApi.getBBoardAPI()!;
  let currentState: BBoardDerivedState | undefined;
  const stateObserver = {
    next: (state: BBoardDerivedState) => (currentState = state),
  };
  const subscription = bboardApi.state$.subscribe(stateObserver);
  
  try {
    while (true) {
      // Generate completely dynamic menu items based on contract analysis
      const menuItems = enhancedApi.generateMenuItems();
      const menuQuestion = enhancedApi.generateMenuQuestion(menuItems);
      const choice = await rli.question(menuQuestion);
      
      // Find the selected menu item
      const selectedItem = menuItems.find(item => item.key === choice);
      
      if (selectedItem) {
        if (selectedItem.label === 'Exit') {
          logger.info('Exiting...');
          return;
        }
        
        // Execute the dynamic handler for any menu item
        try {
          await selectedItem.handler(providers, enhancedApi.deployedContract, rli);
        } catch (error) {
          logger.error(`‚ùå Failed to execute ${selectedItem.label}: ${error instanceof Error ? error.message : String(error)}`);
        }
      } else {
        logger.error(`Invalid choice: ${choice}`);
      }
    }
  } finally {
    // Clean up global references
    delete (global as any).enhancedApi;
    delete (global as any).getBBoardLedgerState;
    delete (global as any).displayLedgerState;
    delete (global as any).displayPrivateState;
    delete (global as any).displayDerivedState;
    
    // While we allow errors to bubble up to the 'run' function, we will always need to dispose of the state
    // subscription when we exit.
    subscription.unsubscribe();
  }
};

/* **********************************************************************
 * createWalletAndMidnightProvider: returns an object that
 * satifies both the WalletProvider and MidnightProvider
 * interfaces, both implemented in terms of the given wallet.
 */

const createWalletAndMidnightProvider = async (wallet: Wallet): Promise<WalletProvider & MidnightProvider> => {
  const state = await Rx.firstValueFrom(wallet.state());
  return {
    coinPublicKey: state.coinPublicKey,
    encryptionPublicKey: state.encryptionPublicKey,
    balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
      return wallet
        .balanceTransaction(
          ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
          newCoins,
        )
        .then((tx) => wallet.proveTransaction(tx))
        .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
        .then(createBalancedTx);
    },
    submitTx(tx: BalancedTransaction): Promise<TransactionId> {
      return wallet.submitTransaction(tx);
    },
  };
};

/* **********************************************************************
 * waitForFunds: wait for tokens to appear in a wallet.
 *
 * This is an interesting example of watching the stream of states
 * coming from the pub-sub indexer.  It watches both
 *  1. how close the state is to present reality and
 *  2. the balance held by the wallet.
 */

const waitForFunds = (wallet: Wallet, logger: Logger) =>
  Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.throttleTime(10_000),
      Rx.tap((state) => {
        const scanned = state.syncProgress?.synced ?? 0n;
        const behind = state.syncProgress?.lag.applyGap.toString() ?? 'unknown number';
        logger.info(`Wallet processed ${scanned} indices, remaining ${behind}`);
      }),
      Rx.filter((state) => {
        // Let's allow progress only if wallet is close enough
        const synced = typeof state.syncProgress?.synced === 'bigint' ? state.syncProgress.synced : 0n;
        const total = typeof state.syncProgress?.lag?.applyGap === 'bigint' ? state.syncProgress.lag.applyGap : 1_000n;
        return total - synced < 100n;
      }),
      Rx.map((s) => s.balances[nativeToken()] ?? 0n),
      Rx.filter((balance) => balance > 0n),
    ),
  );

/* **********************************************************************
 * buildWalletAndWaitForFunds: the main function that creates a wallet
 * and waits for tokens to appear in it.  The various "buildWallet"
 * functions all arrive here after collecting information for the
 * arguments.
 */

const buildWalletAndWaitForFunds = async (
  { indexer, indexerWS, node, proofServer }: Config,
  logger: Logger,
  seed: string,
): Promise<Wallet & Resource> => {
  const wallet = await WalletBuilder.buildFromSeed(
    indexer,
    indexerWS,
    proofServer,
    node,
    seed,
    getZswapNetworkId(),
    'warn',
  );
  wallet.start();
  const state = await Rx.firstValueFrom(wallet.state());
  logger.info(`Your wallet seed is: ${seed}`);
  logger.info(`Your wallet address is: ${state.address}`);
  let balance = state.balances[nativeToken()];
  if (balance === undefined || balance === 0n) {
    logger.info(`Your wallet balance is: 0`);
    logger.info(`Waiting to receive tokens...`);
    balance = await waitForFunds(wallet, logger);
  }
  logger.info(`Your wallet balance is: ${balance}`);
  return wallet;
};

// Generate a random see and create the wallet with that.
const buildFreshWallet = async (config: Config, logger: Logger): Promise<Wallet & Resource> =>
  await buildWalletAndWaitForFunds(config, logger, toHex(utils.randomBytes(32)));

// Prompt for a seed and create the wallet with that.
const buildWalletFromSeed = async (config: Config, rli: Interface, logger: Logger): Promise<Wallet & Resource> => {
  const seed = await rli.question('Enter your wallet seed: ');
  return await buildWalletAndWaitForFunds(config, logger, seed);
};

/* ***********************************************************************
 * This seed gives access to tokens minted in the genesis block of a local development node - only
 * used in standalone networks to build a wallet with initial funds.
 */

/* **********************************************************************
 * buildWallet: unless running in a standalone (offline) mode,
 * prompt the user to tell us whether to create a new wallet
 * or recreate one from a prior seed.
 */



const buildWallet = async (config: Config, rli: Interface, logger: Logger): Promise<(Wallet & Resource) | null> => {
  if (config instanceof StandaloneConfig) {
    return await buildWalletAndWaitForFunds(config, logger, GENESIS_MINT_WALLET_SEED);
  }
  
  // Check if WALLET_SEED is available in environment variables
  const envSeed = process.env.WALLET_SEED;
  console.log('Using wallet seed from .env file');
  if (envSeed) {
    logger.info('Using wallet seed from .env file');
    return await buildWalletAndWaitForFunds(config, logger, envSeed);
  }
  else {
    return await buildWalletAndWaitForFunds(config, logger, GENESIS_MINT_WALLET_SEED);
  }
};

/* **********************************************************************
 * createDynamicZkConfigProvider: creates a zkConfigProvider that 
 * dynamically discovers circuit names from the contract
 */

const createDynamicZkConfigProvider = async (config: Config): Promise<NodeZkConfigProvider<any>> => {
  try {
    // Use the contract analyzer to discover circuit names
    const { ContractAnalyzer } = await import('./contract-analyzer.js');
    const analyzer = new ContractAnalyzer();
    const analysis = await analyzer.analyzeContract();
    
    // Extract circuit names from the analyzed functions
    const circuitNames = analysis.functions.map(func => func.name);
    
    console.log('üîç Detected circuits:', circuitNames);
    
    // For now, we'll use the config path approach but we know the circuit names
    // The NodeZkConfigProvider will look for the circuit files automatically
    return new NodeZkConfigProvider<any>(config.zkConfigPath);
  } catch (error) {
    console.error('Failed to analyze contract for dynamic circuits:', error);
    // Fallback to default provider
    return new NodeZkConfigProvider<any>(config.zkConfigPath);
  }
};

const mapContainerPort = (env: StartedDockerComposeEnvironment, url: string, containerName: string) => {
  const mappedUrl = new URL(url);
  const container = env.getContainer(containerName);

  mappedUrl.port = String(container.getFirstMappedPort());

  return mappedUrl.toString().replace(/\/+$/, '');
};

/* **********************************************************************
 * run: the main entry point that starts the whole bulletin board CLI.
 *
 * If called with a Docker environment argument, the application
 * will wait for Docker to be ready before doing anything else.
 */

export const run = async (config: Config, logger: Logger, dockerEnv?: DockerComposeEnvironment): Promise<void> => {
  const rli = createInterface({ input, output, terminal: true });
  let env;
  if (dockerEnv !== undefined) {
    env = await dockerEnv.up();

    if (config instanceof StandaloneConfig) {
      config.indexer = mapContainerPort(env, config.indexer, 'bboard-indexer');
      config.indexerWS = mapContainerPort(env, config.indexerWS, 'bboard-indexer');
      config.node = mapContainerPort(env, config.node, 'bboard-node');
      config.proofServer = mapContainerPort(env, config.proofServer, 'bboard-proof-server');
    }
  }
  const wallet = await buildWallet(config, rli, logger);
  try {
    if (wallet !== null) {
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
      const providers = {
        privateStateProvider: levelPrivateStateProvider<PrivateStateId>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: await createDynamicZkConfigProvider(config),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      await mainLoop(providers, rli, logger);
    }
  } catch (e) {
    logError(logger, e);
    logger.info('Exiting...');
  } finally {
    try {
      rli.close();
      rli.removeAllListeners();
    } catch (e) {
      logError(logger, e);
    } finally {
      try {
        if (wallet !== null) {
          await wallet.close();
        }
      } catch (e) {
        logError(logger, e);
      } finally {
        try {
          if (env !== undefined) {
            await env.down();
            logger.info('Goodbye');
            process.exit(0);
          }
        } catch (e) {
          logError(logger, e);
        }
      }
    }
  }
};

function logError(logger: Logger, e: unknown) {
  if (e instanceof Error) {
    logger.error(`Found error '${e.message}'`);
    logger.debug(`${e.stack}`);
  } else {
    logger.error(`Found error (unknown type)`);
  }
}
